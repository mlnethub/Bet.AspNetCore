using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Bet.AspNetCore.LetsEncrypt.Abstractions;
using Bet.AspNetCore.LetsEncrypt.Options;
using Bet.Extensions.Hosting;
using Bet.Extensions.Hosting.Abstractions;

using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Bet.AspNetCore.LetsEncrypt.Internal
{
    /// <summary>
    /// This class provides with ability to check if the existing certificates in the specified storage are valid, if not
    /// the order request is issued.
    /// </summary>
    internal class CertificateRenewalService : TimedHostedService
    {
        // see https://github.com/aspnet/Common/blob/61320f4ecc1a7b60e76ca8fe05cd86c98778f92c/shared/Microsoft.AspNetCore.Certificates.Generation.Sources/CertificateManager.cs#L19-L20
        // This is the unique OID for the developer cert generated by VS and the .NET Core CLI
        private const string AspNetHttpsOid = "1.3.6.1.4.1.311.84.1.1";
        private const string AspNetHttpsOidFriendlyName = "ASP.NET Core HTTPS development certificate";

        private readonly ILetsEncryptService _letsEncryptService;
        private readonly ILogger<ITimedHostedService> _logger;
        private readonly ICertificateStore _certificateStore;
        private readonly CertificateSelector _certificateSelector;

        private LetsEncryptOptions _options;

        public CertificateRenewalService(
            CertificateSelector certificateSelector,
            IOptionsMonitor<LetsEncryptOptions> letsEncryptOptions,
            ICertificateStore certificateStore,
            ILetsEncryptService letsEncryptService,
            IOptionsMonitor<TimedHostedServiceOptions> options,
            IEnumerable<ITimedHostedLifeCycleHook> lifeCycleHooks,
            ILogger<ITimedHostedService> logger) : base(options, lifeCycleHooks, logger)
        {
            _certificateSelector = certificateSelector ?? throw new System.ArgumentNullException(nameof(certificateSelector));

            _options = letsEncryptOptions.CurrentValue;
            letsEncryptOptions.OnChange(newOptions => _options = newOptions);

            _letsEncryptService = letsEncryptService ?? throw new System.ArgumentNullException(nameof(letsEncryptService));
            _logger = logger ?? throw new System.ArgumentNullException(nameof(logger));
            _certificateStore = certificateStore ?? throw new System.ArgumentNullException(nameof(certificateStore));

            TaskToExecuteAsync = (token) => RequestCertificate(token);
        }

        public async Task RequestCertificate(CancellationToken cancellationToken)
        {
            await Authentication(cancellationToken);

            var hostNames = _certificateSelector.GetCertificatesAboutToExpire();

            if (_options.IsDevelopment)
            {
                FindDeveloperCert();
            }

            foreach (var hostName in _options.HostNames)
            {
                var existingCert = await _certificateStore.GetCertificateAsync(hostName, cancellationToken);

                if (existingCert == null)
                {
                    var (cert, rawCert) = await _letsEncryptService.AcquireNewCertificateForHosts(
                        hostName,
                        _options.CertificateSigningRequest,
                        _options.CertificateFriendlyName,
                        _options.CertificatePassword,
                        cancellationToken);

                    existingCert = cert;
                    await _certificateStore.SaveCertificateAsync(hostName, rawCert, cancellationToken);
                }

                _certificateSelector.Use(hostName, existingCert);
            }
        }

        public async Task Authentication(CancellationToken cancellationToken)
        {
            var accountKey = await _certificateStore.GetAccountAsync(cancellationToken);

            if (accountKey != null)
            {
                await _letsEncryptService.AuthenticateWithExistingAccount(_options.AcmeServer, accountKey, cancellationToken);
            }
            else
            {
                accountKey = await _letsEncryptService.AuthenticateWithNewAccount(_options.Email, _options.AcmeServer, true, cancellationToken);
                await _certificateStore.SaveAccountAsync(accountKey, cancellationToken);
            }
        }

        private void FindDeveloperCert()
        {
            using (var store = new X509Store(StoreName.My, StoreLocation.CurrentUser))
            {
                store.Open(OpenFlags.ReadOnly);
                var certs = store.Certificates.Find(X509FindType.FindByExtension, AspNetHttpsOid, validOnly: false);
                if (certs.Count == 0)
                {
                    _logger.LogDebug("Could not find the " + AspNetHttpsOidFriendlyName);
                }
                else
                {
                    _logger.LogDebug("Using the " + AspNetHttpsOidFriendlyName + " for 'localhost' requests");
                    _certificateSelector.Use("localhost", certs[0]);
                }
            }
        }
    }
}
